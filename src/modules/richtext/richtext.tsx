import React from "react";
import { stringGroups, wrapPartitions } from "~src/utils";
import { decodeImage, picture } from "../newsendpics/image-process";
import { urlImageDirectLinkAny } from "./linkutils";
import { wrapLinks } from "./messagelinks";

const str1 = (s: string) => s.split("");
const str2 = (s: string) => stringGroups(s, 2);

// blackboard bold is more complex due to variable-byte glyphs, not included

const textDecoration = {
  none: str1("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"),
  italic: str2("ð˜¢ð˜£ð˜¤ð˜¥ð˜¦ð˜§ð˜¨ð˜©ð˜ªð˜«ð˜¬ð˜­ð˜®ð˜¯ð˜°ð˜±ð˜²ð˜³ð˜´ð˜µð˜¶ð˜·ð˜¸ð˜¹ð˜ºð˜»ð˜ˆð˜‰ð˜Šð˜‹ð˜Œð˜ð˜Žð˜ð˜ð˜‘ð˜’ð˜“ð˜”ð˜•ð˜–ð˜—ð˜˜ð˜™ð˜šð˜›ð˜œð˜ð˜žð˜Ÿð˜ ð˜¡"),
  bold: str2("ð—®ð—¯ð—°ð—±ð—²ð—³ð—´ð—µð—¶ð—·ð—¸ð—¹ð—ºð—»ð—¼ð—½ð—¾ð—¿ð˜€ð˜ð˜‚ð˜ƒð˜„ð˜…ð˜†ð˜‡ð—”ð—•ð—–ð——ð—˜ð—™ð—šð—›ð—œð—ð—žð—Ÿð— ð—¡ð—¢ð—£ð—¤ð—¥ð—¦ð—§ð—¨ð—©ð—ªð—«ð—¬ð—­ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµ"),
  boldItalic: str2("ð™–ð™—ð™˜ð™™ð™šð™›ð™œð™ð™žð™Ÿð™ ð™¡ð™¢ð™£ð™¤ð™¥ð™¦ð™§ð™¨ð™©ð™ªð™«ð™¬ð™­ð™®ð™¯ð˜¼ð˜½ð˜¾ð˜¿ð™€ð™ð™‚ð™ƒð™„ð™…ð™†ð™‡ð™ˆð™‰ð™Šð™‹ð™Œð™ð™Žð™ð™ð™‘ð™’ð™“ð™”ð™•"),
  underline: str2(
    "aÍŸbÍŸcÍŸdÍŸeÍŸfÍŸgÍŸhÍŸiÍŸjÍŸkÍŸlÍŸmÍŸnÍŸoÍŸpÍŸqÍŸrÍŸsÍŸtÍŸuÍŸvÍŸwÍŸxÍŸyÍŸzÍŸAÍŸBÍŸCÍŸDÍŸEÍŸFÍŸGÍŸHÍŸIÍŸJÍŸKÍŸLÍŸMÍŸNÍŸOÍŸPÍŸQÍŸRÍŸSÍŸTÍŸUÍŸVÍŸWÍŸXÍŸYÍŸZÍŸ0ÍŸ1ÍŸ2ÍŸ3ÍŸ4ÍŸ5ÍŸ6ÍŸ7ÍŸ8ÍŸ9ÍŸ"
  ),
  squared: str2("ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰"),
  squaredFull: str2("ðŸ…°ðŸ…±ðŸ…²ðŸ…³ðŸ…´ðŸ…µðŸ…¶ðŸ…·ðŸ…¸ðŸ…¹ðŸ…ºðŸ…»ðŸ…¼ðŸ…½ðŸ…¾ðŸ…¿ðŸ†€ðŸ†ðŸ†‚ðŸ†ƒðŸ†„ðŸ†…ðŸ††ðŸ†‡ðŸ†ˆðŸ†‰ðŸ…°ðŸ…±ðŸ…²ðŸ…³ðŸ…´ðŸ…µðŸ…¶ðŸ…·ðŸ…¸ðŸ…¹ðŸ…ºðŸ…»ðŸ…¼ðŸ…½ðŸ…¾ðŸ…¿ðŸ†€ðŸ†ðŸ†‚ðŸ†ƒðŸ†„ðŸ†…ðŸ††ðŸ†‡ðŸ†ˆðŸ†‰"),
  circled: str1(
    "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“žâ“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“Žâ“â“ªâ‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨"
  ),
  superscript: str1(
    "áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°á¶¦Ê²áµË¡áµâ¿áµ’áµ–áµ Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾áµ á´¿Ë¢áµ€áµâ±½áµ‚Ë£Ê¸á¶»â°Â¹Â²Â³â´âµâ¶â·â¸â¹"
  ),
  medieval: str2("ð–†ð–‡ð–ˆð–‰ð–Šð–‹ð–Œð–ð–Žð–ð–ð–‘ð–’ð–“ð–”ð–•ð––ð–—ð–˜ð–™ð–šð–›ð–œð–ð–žð–Ÿð•¬ð•­ð•®ð•¯ð•°ð•±ð•²ð•³ð•´ð•µð•¶ð•·ð•¸ð•¹ð•ºð•»ð•¼ð•½ð•¾ð•¿ð–€ð–ð–‚ð–ƒð–„ð–…"),
  cursive: str2("ð’¶ð’·ð’¸ð’¹ð‘’ð’»ð‘”ð’½ð’¾ð’¿ð“€ð“ð“‚ð“ƒð‘œð“…ð“†ð“‡ð“ˆð“‰ð“Šð“‹ð“Œð“ð“Žð“ð’œðµð’žð’Ÿð¸ð¹ð’¢ð»ð¼ð’¥ð’¦ð¿ð‘€ð’©ð’ªð’«ð’¬ð‘…ð’®ð’¯ð’°ð’±ð’²ð’³ð’´ð’µ"),
  cursiveBold: str2("ð“ªð“«ð“¬ð“­ð“®ð“¯ð“°ð“±ð“²ð“³ð“´ð“µð“¶ð“·ð“¸ð“¹ð“ºð“»ð“¼ð“½ð“¾ð“¿ð”€ð”ð”‚ð”ƒð“ð“‘ð“’ð““ð“”ð“•ð“–ð“—ð“˜ð“™ð“šð“›ð“œð“ð“žð“Ÿð“ ð“¡ð“¢ð“£ð“¤ð“¥ð“¦ð“§ð“¨ð“©"),
  monospace: str1(
    "ï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½Žï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½šï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼ºï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"
  ),
  smallcaps: str1("á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜QÊ€êœ±á´›á´œá´ á´¡xÊá´¢á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜QÊ€êœ±á´›á´œá´ á´¡xÊá´¢"),
  hooked: str1("Î±á‚¦ÆˆÔƒÒ½ÏÉ Ô‹Î¹ÊÆ™Ê…É±É³ÏƒÏÏ™É¾Ê‚ÆšÏ…Ê‹É¯xáƒ§È¥"),
  boldSerif: str2(
    "ðšð›ðœððžðŸð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨ð©ðªð«ð¬ð­ð®ð¯ð°ð±ð²ð³ð€ðð‚ðƒð„ð…ð†ð‡ðˆð‰ðŠð‹ðŒððŽððð‘ð’ð“ð”ð•ð–ð—ð˜ð™ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—"
  )
};

type TextDecoration = keyof typeof textDecoration;

function decorateText(decoration: TextDecoration, text: string): string {
  return text
    .split("")
    .map((char) => {
      const index = textDecoration.none.indexOf(char);
      return textDecoration[decoration][index] ?? char;
    })
    .join("");
}

type Wrap = StringWrapper<JSXSingleton>;

const id = (rest: string) => rest;

export function processImage(
  text: string,
  restWrapper: Wrap = id
): JSXContent | null {
  if (urlImageDirectLinkAny().test(text)) {
    return wrapPartitions(
      text,
      urlImageDirectLinkAny(),
      (url) => picture({ url: `https://${url}` }),
      // Discard surrounding text to get rid of image placeholder text.
      // TODO: Mark placeholder with invis disappearing markup.
      () => ""
    );
  }

  // Downside: text alongside base imgur.com pictures is not displayed
  const image = decodeImage(text);
  if (image !== null) return picture(image);

  return restWrapper(text);
}

function makeMaterialIcon(match: string): JSXContent {
  const className = "material-icons";
  const title = match.toLocaleLowerCase();
  return <span {...{ className, title }}>{match.slice(2, -1)}</span>;
}

function wrapMaterialIcons(text: string, restWrapper: Wrap = id): JSXContent {
  return wrapPartitions(text, /m:[-_a-z]+:/gi, makeMaterialIcon, restWrapper);
}

function makeLineBreaks({ length }: string): JSXContent {
  return length > 1 ? [<br />, <br />] : <br />;
}

function wrapLineBreaks(text: string, restWrapper: Wrap = id): JSXContent {
  const trimmedText = text.replace(/^[\s\n]+|[\s\n]+$/g, "");
  return wrapPartitions(trimmedText, /\n+/g, makeLineBreaks, restWrapper);
}

const markdownStyles: Record<string, TextDecoration> = {
  "[[": "squaredFull",
  "((": "circled",
  "{{": "medieval",
  "*": "italic",
  "_": "italic",
  "**": "bold",
  "__": "underline",
  "***": "boldItalic",
  "`": "monospace",
  "^^": "superscript",
  ",,": "hooked"
};

const markdownDelimiters = Object.getOwnPropertyNames(markdownStyles) as Array<
  keyof typeof markdownStyles
>;
markdownDelimiters.sort((a, b) => b.length - a.length);

function mirrorDelimiter(delim: string): string {
  if (delim === "[[") return "]]";
  if (delim === "((") return "))";
  if (delim === "{{") return "}}";
  return delim;
}

function makeMarkdown(text: string): string {
  const delim = markdownDelimiters.find(
    (d) => text.startsWith(d) && text.endsWith(mirrorDelimiter(d))
  );
  if (delim === undefined) return text;
  const contents = text.slice(delim.length, -delim.length);
  const delimLast = delim.slice(-1)[0];
  if (contents.split("").every((char) => char === delimLast)) return text;
  return decorateText(markdownStyles[delim], contents);
}

export function wrapMarkdown(
  text: string,
  restWrapper: StringWrapper<string> = id
): string {
  return wrapPartitions<string, string>(
    text,
    /(?<=\s|^|\.,;!\?)(\*{1,3}|_{1,2}|~~|`|\^\^|,,|\[{2}|\({2}|\{{2})\S(?:.*?\S)?(?:\1|\]{2}|\){2}|\}{2})(?=\s|$|\.,;!\?)/g,
    makeMarkdown,
    restWrapper
  ).join("");
}

export function wrapRich(text: string, restWrapper: Wrap = id): JSXContent {
  return wrapLineBreaks(text, (line) =>
    wrapMaterialIcons(line, (nonIcon) => wrapLinks(nonIcon, restWrapper))
  );
}
